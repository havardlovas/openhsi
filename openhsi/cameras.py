# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/cameras/cameras.ipynb.

# %% auto 0
__all__ = ['WebCamera', 'switched_camera', 'FlirCameraBase', 'FlirCamera', 'SharedFlirCamera', 'IDSCam', 'IDSCameraBase', 'IDSCamera', 'SharedIDSCamera', 'LucidCameraBase', 'LucidCamera', 'SharedLucidCamera', 'XimeaCameraBase', 'XimeaCamera', 'SharedXimeaCamera']

# %% ../nbs/api/cameras/cameras.ipynb 5
# monkey patching class methods using @patch
from fastcore.foundation import *
from fastcore.foundation import patch

# bring forth **kwargs from an inherited class for documentation
from fastcore.meta import delegates

# external
import numpy as np
import ctypes
import matplotlib.pyplot as plt
import warnings
from tqdm import tqdm
from functools import partial

# internal
from .capture import OpenHSI
from .shared import SharedOpenHSI

# %% ../nbs/api/cameras/cameras.ipynb 7
@delegates()
class WebCamera(OpenHSI):
    """Interface for webcam to test OpenHSI functionality"""
    def __init__(self, mode:str = None, **kwargs):
        """Initialise Webcam"""
        super().__init__(**kwargs)
        
        import cv2
        
        # Check if the webcam is opened correctly
        self.vid = cv2.VideoCapture(0)
        if not self.vid.isOpened():
            raise IOError("Cannot open webcam")
        
        self.rgb2gray = partial(cv2.cvtColor, code=cv2.COLOR_RGB2GRAY)
        self.resize   = partial(cv2.resize, dsize=tuple(np.flip(self.settings["resolution"])), interpolation=cv2.INTER_AREA)
        self.close    = cv2.destroyAllWindows
        
    def start_cam(self):
        pass
    
    def stop_cam(self):
        self.vid.release()
        self.close()
    
    def get_img(self) -> np.ndarray:
        ret, frame = self.vid.read()
        frame = self.rgb2gray(frame)
        frame = self.resize(frame)
        return frame
    
    def get_temp(self) -> float:
        return 20.0

# %% ../nbs/api/cameras/cameras.ipynb 12
def switched_camera(
    cam_class:str      = None, # Camera Class Name from openhsi.cameras
    n_lines:int        = 128, # how many along-track pixels
    processing_lvl:int = 0, # desired processing done in real time
    json_path:str      = "/media/pi/fastssd/cals/flir_settings.json", # path to settings file
    pkl_path:str       = "/media/pi/fastssd/cals/flir_calibration.pkl", # path to calibration file
    preconfig_meta:str = "/media/pi/fastssd/cals/preconfig_metadata.json", # path to metadata file
    ssd_dir:str        = "/media/pi/fastssd", # path to SSD
    toggle_interface   = None, # toggle_interface that controls collection
):
    """If `toggle_interface.status` is True, collect with the camera until switched is False."""
        
    cam = cam_class(n_lines = n_lines, processing_lvl = processing_lvl, 
                     json_path = json_path, 
                     pkl_path  = pkl_path)
    cam.start_cam()
    while toggle_interface.status == True: # collect while go button is on.
        cam.collect()
        if 'p' in locals():
            p.join()  # wait for the last process to finish so we don't modify the data when it's being saved
            pass
        p = cam.save(ssd_dir, preconfig_meta_path=preconfig_meta)
        
    cam.stop_cam()

# %% ../nbs/api/cameras/flir.ipynb 6
@delegates()
class FlirCameraBase():
    """Interface for FLIR camera"""
    
    def __init__(self, **kwargs):
        """Initialise FLIR camera"""
        super().__init__(**kwargs)
        
        from simple_pyspin import Camera
        
        self.flircam = Camera()
        self.flircam.init()
        self.flircam.GainAuto = 'Off'
        self.flircam.Gain = 0
        self.flircam.AcquisitionFrameRateAuto = 'Off'
        self.flircam.AcquisitionFrameRateEnabled = True
        self.flircam.AcquisitionFrameRate = int( min(1_000/(self.settings["exposure_ms"]+1),120) )
    
        self.flircam.ExposureAuto = 'Off'
        self.flircam.ExposureTime = self.settings["exposure_ms"]*1e3 # convert to us
        self.flircam.GammaEnabled = False
        
        self.flircam.Width = self.flircam.SensorWidth if self.settings["win_resolution"][1] == 0 else self.settings["win_resolution"][1]
        self.flircam.Height = self.flircam.SensorHeight if self.settings["win_resolution"][0] == 0 else self.settings["win_resolution"][0]
        self.flircam.OffsetY, self.flircam.OffsetX = self.settings["win_offset"]

    
    def start_cam(self):
        self.flircam.start()
    
    def stop_cam(self):
        self.flircam.stop()
        
    def __close__(self):
        self.flircam.close()
    
    def get_img(self) -> np.ndarray:
        return self.flircam.get_array()
    
    def get_temp(self) -> float:
        return self.flircam.DeviceTemperature
    
    def set_exposure(self, exposure_ms:float):
        """sets the FLIR camera exposure time to `exposure_ms`."""
        self.settings["exposure_ms"] = exposure_ms
        
        self.flircam.AcquisitionFrameRateAuto = 'Off'
        self.flircam.AcquisitionFrameRateEnabled = True
        self.flircam.AcquisitionFrameRate = int( min(1_000/(self.settings["exposure_ms"]+1),120) )
        self.flircam.ExposureAuto = 'Off'
        self.flircam.ExposureTime = self.settings["exposure_ms"]*1e3 # convert to us
        
@delegates()
class FlirCamera(OpenHSI, FlirCameraBase):
    pass

# %% ../nbs/api/cameras/flir.ipynb 9
@delegates()
class SharedFlirCamera(FlirCameraBase, SharedOpenHSI):
    pass

# %% ../nbs/api/cameras/ids_peak.ipynb 7
"""
@file    reconnect_callbacks.py
@author  IDS Imaging Development Systems GmbH
@date    2023-11-08

@brief   This application demonstrates how to register device connection change callbacks and handle a reconnected device

@version 1.0.1

Copyright (C) 2023 - 2024, IDS Imaging Development Systems GmbH.

The information in this document is subject to change without notice
and should not be construed as a commitment by IDS Imaging Development Systems GmbH.
IDS Imaging Development Systems GmbH does not assume any responsibility for any errors
that may appear in this document.

This document, or source code, is provided solely as an example of how to utilize
IDS Imaging Development Systems GmbH software libraries in a sample application.
IDS Imaging Development Systems GmbH does not assume any responsibility
for the use or reliability of any portion of this document.

General permission to copy or modify is hereby granted.
"""
from ids_peak import ids_peak
from ids_peak_ipl import ids_peak_ipl
from ids_peak import ids_peak_ipl_extension

from typing import Optional


class IDSCam:
    def __init__(self):
        # Initialize library, has to be matched by a Library.Close() call
        ids_peak.Library.Initialize()

        self.device_manager: ids_peak.DeviceManager = ids_peak.DeviceManager.Instance()
        self.acquisition_running: bool = False
        self.device: Optional[ids_peak.Device] = None
        self.remote_nodemap: Optional[ids_peak.NodeMap] = None
        self.data_stream: Optional[ids_peak.DataStream] = None

        self.register_callbacks()

    @staticmethod
    def device_found(device: ids_peak.DeviceDescriptor):
        """
        The 'found' event is triggered if a new device is found upon calling
        `DeviceManager.Update()`
        """
        print(f"Found-Device-Callback: Key={device.Key()}")

    @staticmethod
    def device_lost(key: str):
        """
        The 'lost' event is only called for this application's opened devices if
        a device is closed explicitly or if connection is lost while the reconnect is disabled,
        otherwise the 'disconnected' event is triggered.
        Other devices that were not opened or were opened by someone else still trigger
        a 'lost' event.
        """
        print(f"Lost-Device-Callback: Key={key}")

    def ensure_compatible_buffers_and_restart_acquisition(
            self,
            reconnect_information: ids_peak.DeviceReconnectInformation
    ):
        """
        After a reconnect the PayloadSize might have changed, e.g. due to
        a reboot and the last parameter state not being saved in the
        starting UserSet. Here we check the PayloadSize and
        reallocate the buffers if we encounter a mismatch.

        We also start the local and remote acquistion if necessary.
        """
        payload_size = self.remote_nodemap.FindNode("PayloadSize").Value()

        has_payload_size_mismatch = payload_size != self.data_stream.AnnouncedBuffers()[
            0].Size()

        # The payload size might have changed. In this case it's required to reallocate the buffers.
        if has_payload_size_mismatch:
            print("PayloadSize has changed. Reallocating buffers...")

            is_data_stream_running = self.data_stream.IsGrabbing()
            if is_data_stream_running:
                self.data_stream.StopAcquisition()

            self.revoke_buffers()

            # Allocate and queue the buffers using the new "PayloadSize".
            self.alloc_buffers()

            if is_data_stream_running:
                self.data_stream.StartAcquisition()

        if not reconnect_information.IsRemoteDeviceAcquisitionRunning():
            self.remote_nodemap.FindNode("AcquisitionStart").Execute()

    def device_reconnected(self, device: ids_peak.Device,
                           reconnect_information: ids_peak.DeviceReconnectInformation):
        """
        When a device that was opened by the same application instance regains connection
        after a previous disconnect the 'Reconnected' event is triggered.

        The reconnect may (partially) fail, so we have to check the `DeviceReconnectInformation`
        class to know what steps are necessary to resume the acquistion.
        """
        print((
            "Device-Reconnected-Callback:/n"
            f"Key={device.Key()}\n"
            f"ReconnectSuccessful: {reconnect_information.IsSuccessful()}/n"
            f"RemoteDeviceAcquisitionRunning: {reconnect_information.IsRemoteDeviceAcquisitionRunning()}/n"
            f"RemoteDeviceConfigurationRestored: {reconnect_information.IsRemoteDeviceConfigurationRestored()}"
        ))

        # Using the `reconnectInformation` the user can tell whether they need to take actions
        # in order to resume the image acquisition.
        if reconnect_information.IsSuccessful():
            # Device was reconnected successfully, nothing to do.
            return

        self.ensure_compatible_buffers_and_restart_acquisition(
            reconnect_information)

    @staticmethod
    def device_disconnected(device: ids_peak.DeviceDescriptor):
        """
        Only called if the reconnect is enabled and if the device was previously opened by this
        application instance.
        """
        print(f"Disconnected-Callback: Key={device.Key()}")

    def register_callbacks(self):
        """
        Register the Devicemanager callbacks.

        Note: We have to store the callbacks, otherwise the callbacks will be unregistered because their
        lifetime is shorter than the device manager instance.
        """
        # ids_peak provides several events that you can subscribe to in order
        # to be notified when the connection status of a device changes.
        self.device_found_callback = self.device_manager.DeviceFoundCallback(
            self.device_found)
        self.device_found_callback_handle = self.device_manager.RegisterDeviceFoundCallback(
            self.device_found_callback)

        self.device_lost_callback = self.device_manager.DeviceLostCallback(
            self.device_lost)
        self.device_lost_callback_handle = self.device_manager.RegisterDeviceLostCallback(
            self.device_lost_callback)

        self.device_reconnected_callback = self.device_manager.DeviceReconnectedCallback(
            self.device_reconnected)
        self.device_reconnected_callback_handle = self.device_manager.RegisterDeviceReconnectedCallback(
            self.device_reconnected_callback)

        self.device_disconnected_callback = self.device_manager.DeviceDisconnectedCallback(
            self.device_disconnected)
        self.device_disconnected_callback_handle = self.device_manager.RegisterDeviceDisconnectedCallback(
            self.device_disconnected_callback)

    def unregister_callbacks(self):
        """
        Unregister the registered callbacks inside the Devicemanager
        """
        self.device_manager.UnregisterDeviceFoundCallback(
            self.device_found_callback_handle)
        self.device_manager.UnregisterDeviceLostCallback(
            self.device_lost_callback_handle)
        self.device_manager.UnregisterDeviceReconnectedCallback(
            self.device_reconnected_callback_handle)
        self.device_manager.UnregisterDeviceDisconnectedCallback(
            self.device_disconnected_callback_handle)

    def run_acquisition_loop(self):
        """
        Run the acquisition loop. The reconnect callback may abort this.
        """

        # Lock writeable nodes during acquisition
        self.remote_nodemap.FindNode("TLParamsLocked").SetValue(1)

        self.data_stream.StartAcquisition()
        self.remote_nodemap.FindNode("AcquisitionStart").Execute()
        self.remote_nodemap.FindNode("AcquisitionStart").WaitUntilDone()

        self.acquisition_running = True
        print("Starting acquisition...")
        print("Now you can disconnect or reboot the device to trigger a reconnect!")
        while self.acquisition_running:
            try:
                # Wait for finished/filled buffer event
                buffer = self.data_stream.WaitForFinishedBuffer(
                    ids_peak.Timeout.INFINITE_TIMEOUT)
                print(f"Received FrameID: {buffer.FrameID()}")
                # Put the buffer back in the pool, so it can be filled again
                self.data_stream.QueueBuffer(buffer)
            except KeyboardInterrupt:
                print("Keyboard interrupt.")
                break
            except Exception as e:
                print(f"Exception: {e}")

        print("Stopping acquisition...")
        self.remote_nodemap.FindNode("AcquisitionStop").Execute()
        self.remote_nodemap.FindNode("AcquisitionStop").WaitUntilDone()
        self.data_stream.StopAcquisition(
            ids_peak.AcquisitionStopMode_Default)

        # Unlock writeable nodes again
        self.remote_nodemap.FindNode("TLParamsLocked").SetValue(0)
    



    def get_image(self):
        # Tries to access a image
        try:
            # Get buffer from device's DataStream. Wait 5000 ms. The buffer is automatically locked until it is queued again.
            
            buffer = self.data_stream.WaitForFinishedBuffer(5000)
        
            
            
            """image = ids_peak_ipl.BufferToImage(buffer)
"""
            image = ids_peak_ipl.Image.CreateFromSizeAndBuffer(
                buffer.PixelFormat(),
                buffer.BasePtr(),
                buffer.Size(),
                buffer.Width(),
                buffer.Height()
            )
            
            #print(buffer.PixelFormat())
            # print(buffer.Width())
            # print(buffer.Height())

            #image_processed = image.ConvertTo(ids_peak_ipl.PixelFormatName_Mono12, ids_peak_ipl.ConversionMode_Classic)
            #print(ids_peak_ipl.Image.get_numpy())
            # Queue buffer again
            self.data_stream.QueueBuffer(buffer)
            
            
            
            return np.transpose(image.get_numpy())
        except Exception as e:
            # ...
            str_error = str(e)
            print(str_error)



    def open_device(self):
        # Open the first device
        device = None
        for dev in self.device_manager.Devices():
            if dev.IsOpenable(ids_peak.DeviceAccessType_Control):
                device = dev.OpenDevice(ids_peak.DeviceAccessType_Control)

        # Exit program if no device was found
        if not device:
            raise Exception("No device found. Exiting Program.")

        self.device = device

        print("Using Device " + self.device.DisplayName())
        self.remote_nodemap = self.device.RemoteDevice().NodeMaps()[0]
        self.data_stream = self.device.DataStreams()[0].OpenDataStream()

    def enable_reconnect(self):
        """
        We enable the reconnect by writing to the `ReconnectEnable` node
        in the `NodeMap` of the `System` that our device is connected to.
        """

        system_node_map = self.device.ParentInterface().ParentSystem().NodeMaps()[0]

        if not system_node_map.HasNode("ReconnectEnable"):
            raise SystemExit("No ReconnectEnable Node found!")

        reconnect_enable_node = system_node_map.FindNode("ReconnectEnable")
        reconnect_enable_access_status = reconnect_enable_node.AccessStatus()

        if reconnect_enable_access_status == ids_peak.NodeAccessStatus_ReadWrite:
            reconnect_enable_node.SetValue(True)
            return

        if reconnect_enable_access_status == ids_peak.NodeAccessStatus_ReadOnly:
            if reconnect_enable_node.Value():
                return

        raise SystemExit("Error: ReconnectEnable cannot be set to true!")

    def load_defaults(self):
        self.remote_nodemap.FindNode(
            "UserSetSelector").SetCurrentEntry("Default")
        # Same as UserSetSelector = Default; in cpp
        self.remote_nodemap.FindNode("UserSetLoad").Execute()
        # Same as UserSetLoad(); in cpp
        self.remote_nodemap.FindNode("UserSetLoad").WaitUntilDone()
        # Same as UserSetLoad(); in cpp
        # ...

        

        #
        

    def alloc_buffers(self):
        # Buffer size
        payload_size = self.remote_nodemap.FindNode("PayloadSize").Value()

        # Minimum number of required buffers
        buffer_count_max = self.data_stream.NumBuffersAnnouncedMinRequired()

        # Allocate buffers and add them to the pool
        for buffer_count in range(buffer_count_max):
            # Let the TL allocate the buffers
            buffer = self.data_stream.AllocAndAnnounceBuffer(payload_size)
            # Put the buffer in the pool
            self.data_stream.QueueBuffer(buffer)

    def revoke_buffers(self):
        # Remove buffers from any associated queue
        self.data_stream.Flush(ids_peak.DataStreamFlushMode_DiscardAll)

        for buffer in self.data_stream.AnnouncedBuffers():
            # Remove buffer from the transport layer
            self.data_stream.RevokeBuffer(buffer)

    def set_roi(self):
        # In order to restart the acquistion additonal steps are required:
        # see "The payload size might have changed." above
        self.remote_nodemap.FindNode("Height").SetValue(512)
        self.remote_nodemap.FindNode("Width").SetValue(512)

    def run(self):
        try:
            # Update the DeviceManager
            ids_peak.DeviceManager.Instance().Update()

            # Open first available device
            self.open_device()

            # Enable reconnect
            self.enable_reconnect()

            # Load default camera settings. This could be replaced with loading from sonfig files
            self.load_defaults()

            exposure_time = 50 # Ms

            self.remote_nodemap.FindNode("ExposureTime").SetValue(exposure_time)

            # NOTE: Uncommenting this line will modify the PayloadSize without saving the
            # changes in the UserSet. If the device reboots (e.g. by losing and then regaining
            # power) the PayloadSize will have changed, which means the acquisition on
            # the remote device will not be restarted.
            # self.set_roi()

            # Allocate buffers for the acquisition
            self.alloc_buffers()

            # Run acquisition loop until an error occurs or the user presses Ctrl+C
            self.run_acquisition_loop()

            # Revoke all buffers
            self.revoke_buffers()

        except ids_peak.AbortedException:
            print("Aborted")
        except Exception as e:
            print("EXCEPTION: " + str(e))
            return -2

        finally:
            self.unregister_callbacks()
            ids_peak.Library.Close()


"""if __name__ == '__main__':
    example = IDSCam()
    example.run()"""


# %% ../nbs/api/cameras/ids_peak.ipynb 8
@delegates()
class IDSCameraBase(OpenHSI):
    """Interface for IDS camera"""
    
    def __init__(self, **kwargs):
        """Initialise IDS camera
        
        Any keyword-value pair arguments must match the those avaliable in settings file. IDSCamera expects the ones listed below:

        - `binxy`: number of pixels to bin in (x,y) direction
        - `win_resolution`: size of area on detector to readout (width, height)
        - `win_offset`: offsets (x,y) from edge of detector for a selective 
        - `exposure_ms`: is the camera exposure time to use
        - `pixel_format`: format of pixels readout sensor, ie Mono8, Mono10, Mono12
    """
        print("IDSCameraBase __init__")
        print(kwargs)
        super().__init__(**kwargs)
        
        self.idscam = IDSCam()

        # Update the DeviceManager
        ids_peak.DeviceManager.Instance().Update()

        # Open first available device
        self.idscam.open_device()

        # Enable reconnect
        self.idscam.enable_reconnect()

        # Load default camera settings. This could be replaced with loading from sonfig files
        self.idscam.load_defaults()

        p_format = self.settings['pixel_format']

        if p_format == 'Mono8':
            # Set high pixel-clock
            self.idscam.remote_nodemap.FindNode("DeviceClockFrequency").SetValue(474e6) # (allows ~80 FPS)

        # Else leave the pixel clock at default 237 (allows ~80 FPS)
        clock_freq = self.idscam.remote_nodemap.FindNode("DeviceClockFrequency").Value() # 30, 59, 118 , 237, 474

        print(f"The current clock frequency is {clock_freq}")


        # Set all the settings
        
        
        self.idscam.remote_nodemap.FindNode("PixelFormat").SetCurrentEntry(p_format)

        max_frame_rate = self.idscam.remote_nodemap.FindNode("AcquisitionFrameRate").Maximum()

        print(f'The maximal frame rate is {max_frame_rate} for pixelformat {p_format}')

        frame_rate = int( min(1_000/(self.settings["exposure_ms"]), max_frame_rate) )

        # Change this stuff if you want to harware trigger from strobe light
        self.idscam.remote_nodemap.FindNode("AcquisitionMode").SetCurrentEntry("Continuous")
        self.idscam.remote_nodemap.FindNode("TriggerSelector").SetCurrentEntry("ExposureStart")
        self.idscam.remote_nodemap.FindNode("TriggerMode").SetCurrentEntry("Off")
        self.idscam.remote_nodemap.FindNode("AcquisitionFrameRate").SetValue(frame_rate)
                         
        # Set Aquisition properties, see https://www.1stvision.com/cameras/IDS/IDS-manuals/en/acquisition-control.html
        #self.idscam.remote_nodemap.FindNode("ExposureMode").SetValue("Timed")

        #self.idscam.remote_nodemap.FindNode("ExposureAuto").SetCurrentEntry("Off")

        # Determine the current ExposureTime (float)
        value = self.idscam.remote_nodemap.FindNode("ExposureTime").Value()
        print(f'{value} mu seconds exposure time')


        #self.idscam.remote_nodemap.FindNode("ExposureTime").SetValue(1000*self.settings["exposure_ms"])

        
        

        ## The following amounts to no correction, i.e. recording raw counts

        #self.idscam.remote_nodemap.FindNode("BalanceWhiteAuto").SetValue("Off")

        # Set the gain to 1 (no transform)
        self.idscam.remote_nodemap.FindNode("GainSelector").SetCurrentEntry("All")
        #self.idscam.remote_nodemap.FindNode("GainAuto").SetCurrentEntry("Off")
        self.idscam.remote_nodemap.FindNode("Gain").SetValue(1.0)

        # Set the blacklevel (offset) to 0
        #self.idscam.remote_nodemap.FindNode("BlackLevelAuto").SetCurrentEntry("Off")
        self.idscam.remote_nodemap.FindNode("BlackLevel").SetValue(0)

        # Set the Gamma to 1
        #self.idscam.remote_nodemap.FindNode("LUTEnable").SetValue(False)
        # Set Gamma to 1.0 (float)
        #self.idscam.remote_nodemap.FindNode("Gamma").SetValue(1.0)

        # Select the right pixel format
        # https://www.1stvision.com/cameras/IDS/IDS-manuals/en/pixel-format.html
        # 12 or 16?
        


        

        

        # Set the ROI:
        sensor_width = self.idscam.remote_nodemap.FindNode("SensorWidth").Value()
        sensor_height = self.idscam.remote_nodemap.FindNode("SensorHeight").Value()

        
    
        width = sensor_width if self.settings["win_resolution"][1] == 0 else self.settings["win_resolution"][1]

        if (width - 96)%8 != 0:
            width = int(np.round((width-96)/8)*8) + 96

        height = sensor_height if self.settings["win_resolution"][0] == 0 else self.settings["win_resolution"][0]
        if (height - 96)%8 != 0:
            height = int(np.round((height-96)/8)*8) + 96

        # Increase frame rate only by smaller SensorHeight for specific UI-3060CP-M-GL Rev.2 (AB00604)

        self.idscam.remote_nodemap.FindNode("Width").SetValue(width)
        self.idscam.remote_nodemap.FindNode("Height").SetValue(height)

        off_x = self.settings["win_offset"][1]
        off_y = self.settings["win_offset"][0]

        if off_x%8 != 0:
            off_x = int(np.round((off_x)/8)*8)

        if off_y%8 != 0:
            off_y = int(np.round((off_y)/8)*8)

        self.idscam.remote_nodemap.FindNode("OffsetX").SetValue(off_x)
        self.idscam.remote_nodemap.FindNode("OffsetY").SetValue(off_y)

        # Binning has no speedup, but may be considered for memory concerns

        

        #self.idscam.remote_nodemap.FindNode("BinningHorizontalMode").SetCurrentEntry("Average")
        #self.idscam.remote_nodemap.FindNode("BinningHorizontal").SetValue(self.settings["binxy"][0])

        # Binning has no speedup, but may be considered for memory concerns
        #self.idscam.remote_nodemap.FindNode("BinningVerticalMode").SetCurrentEntry("Average")
        #self.idscam.remote_nodemap.FindNode("BinningVertical").SetValue(self.settings["binxy"][1])

    
    def start_cam(self):
        # Allocate buffers for the acquisition
        self.idscam.alloc_buffers()
        # Lock transport layer params
        self.idscam.remote_nodemap.FindNode("TLParamsLocked").SetValue(1)

        # Start Aquisition
        self.idscam.data_stream.StartAcquisition()
        self.idscam.remote_nodemap.FindNode("AcquisitionStart").Execute()
        self.idscam.remote_nodemap.FindNode("AcquisitionStart").WaitUntilDone()

        self.idscam.acquisition_running = True
        
    def stop_cam(self):
        # Stop execution
        self.idscam.remote_nodemap.FindNode("AcquisitionStop").Execute()
        self.idscam.remote_nodemap.FindNode("AcquisitionStop").WaitUntilDone()
        #self.idscam.data_stream.StopAcquisition(
        #    ids_peak.AcquisitionStopMode_Default)

        # Unlock writeable nodes again
        self.idscam.remote_nodemap.FindNode("TLParamsLocked").SetValue(0)
        #self.idscam.revoke_buffers()
        
    def __close__(self):
        print('Close method does not exist yet')
    
    def get_img(self) -> np.ndarray:
        return self.idscam.get_image() # Gets image and converts to Numpy array
    
    def get_temp(self) -> float:
        return -1
    
        
@delegates()
class IDSCamera(IDSCameraBase):
    pass
    

# %% ../nbs/api/cameras/ids_peak.ipynb 15
@delegates()
class SharedIDSCamera(IDSCameraBase, SharedOpenHSI):
    pass

# %% ../nbs/api/cameras/lucidvision.ipynb 6
@delegates()
class LucidCameraBase():
    """Core functionality for Lucid Vision Lab cameras
        
        Any keyword-value pair arguments must match the those avaliable in settings file. LucidCamera expects the ones listed below:

        - `binxy`: number of pixels to bin in (x,y) direction
        - `win_resolution`: size of area on detector to readout (width, height)
        - `win_offset`: offsets (x,y) from edge of detector for a selective 
        - `exposure_ms`: is the camera exposure time to use
        - `pixel_format`: format of pixels readout sensor, ie Mono8, Mono10, Mono10p, Mono10Packed, Mono12, Mono12p, Mono12Packed, Mono16
        - `mac_addr`: str = "1c:0f:af:01:7b:a0",
    """
    def __init__(self,**kwargs):
        """Initialise Camera"""
        # https://thinklucid.com/downloads-hub/
        super().__init__(**kwargs)
        
        from arena_api.system import system as arsys
        
        self.arsys = arsys  # make avalaible for later access just in case.
        arsys.destroy_device() # reset an existing connections.
        
        try:
            self.arsys.device_infos
            #self.device = arsys.create_device(device_infos=[{"mac": mac_addr}])[0]
            self.device = arsys.create_device()[0]
        except DeviceNotFoundError as exc:
            raise RuntimeError("DeviceNotFoundError: Please connect a lucid vision camera and run again.") from exc
            
        # allow api to optimise stream
        tl_stream_nodemap = self.device.tl_stream_nodemap
        tl_stream_nodemap["StreamAutoNegotiatePacketSize"].value = True
        tl_stream_nodemap["StreamPacketResendEnable"].value = True

        # init access to device settings
        self.deviceSettings = self.device.nodemap.get_node([
                "AcquisitionFrameRate",
                "AcquisitionFrameRateEnable",
                "AcquisitionMode",
                "AcquisitionStart",
                "AcquisitionStop",
                "BinningHorizontal",
                "BinningVertical",
                "DevicePower",
                "DeviceTemperature",
                "DeviceUpTime",
                "DeviceUserID",
                "ExposureAuto",
                "ExposureTime",
                "Gain",
                "GammaEnable",
                "Height",
                "OffsetX",
                "OffsetY",
                "PixelFormat",
                "ReverseX",
                "ReverseY",
                "Width",
                "GevMACAddress",
                "DeviceSerialNumber"
            ]
        )
        
        # set pixel settings
        self.deviceSettings["BinningHorizontal"].value = self.settings["binxy"][0] # binning is symetric on this sensor, no need to set vertical
        self.deviceSettings["PixelFormat"].value = self.settings["pixel_format"]
        
        # always reset to no window.
        self.deviceSettings["OffsetY"].value = 0
        self.deviceSettings["OffsetX"].value = 0
        self.deviceSettings["Height"].value = self.deviceSettings["Height"].max
        self.deviceSettings["Width"].value = self.deviceSettings["Width"].max
        
        # print("Setting window to: height {}, offset y {}, width {}, offsetx {}".format(self.settings["win_resolution"][0],
        #                                                                     self.settings["win_offset"][0],
        #                                                                     self.settings["win_resolution"][1],
        #                                                                     self.settings["win_offset"][1])
        #      )
        
        # set window up.
        self.deviceSettings["Height"].value = self.settings["win_resolution"][0] if self.settings["win_resolution"][0] > 0 else self.deviceSettings["Height"].max
        self.deviceSettings["Width"].value = self.settings["win_resolution"][1] if self.settings["win_resolution"][1] > 0 else self.deviceSettings["Width"].max
    
        self.deviceSettings["OffsetY"].value = self.settings["win_offset"][0] if self.settings["win_offset"][0] > 0 else self.deviceSettings["OffsetY"].max
        self.deviceSettings["OffsetX"].value = self.settings["win_offset"][1] if self.settings["win_offset"][1] > 0 else self.deviceSettings["OffsetX"].max
        
        # set exposure realted props
        self.deviceSettings["ExposureAuto"].value = "Off" # always off as we need to match exposure to calibration data
        self.set_exposure(self.settings["exposure_ms"])
        
        self.set_gain(0) # default to 0 as we need to match to calibration data
        
        self.rows, self.cols = (
            self.deviceSettings["Height"].value,
            self.deviceSettings["Width"].value,
        )
        
        self.settings['camera_id'] = self.deviceSettings["DeviceUserID"].value

    def __exit__(self, *args, **kwargs):
        self.device.stop_stream()
        self.arsys.destroy_device()

    def start_cam(self):
        self.device.start_stream(1)

    def stop_cam(self):
        self.device.stop_stream()
        
    def set_exposure(self,exposure_ms:float):
        
        if exposure_ms < self.deviceSettings["ExposureTime"].min/1000.0:
            exposure_us=self.deviceSettings["ExposureTime"].min
        else:
            exposure_us = exposure_ms*1000.0
            
        nominal_framerate = 1_000_000.0/exposure_us*0.98
        
        # print("nominal_framerate {}, exposure_us {}".format(nominal_framerate,exposure_us))
        
        if  nominal_framerate < self.deviceSettings['AcquisitionFrameRate'].max:
            self.deviceSettings["AcquisitionFrameRateEnable"].value=True
            self.deviceSettings['AcquisitionFrameRate'].value = nominal_framerate
        else:
            self.deviceSettings["AcquisitionFrameRateEnable"].value=False
            
        self.deviceSettings["ExposureTime"].value = exposure_us # requires time in us float
        self.settings["exposure_ms"] = self.deviceSettings["ExposureTime"].value/1000.00  # exposure time rounds, so storing actual value

    def set_gain(self,gain_val:float):
        self.deviceSettings["Gain"].value = gain_val * 1. # make float always
        
    def get_img(self) -> np.ndarray:
        image_buffer = self.device.get_buffer()
        if image_buffer.bits_per_pixel == 8:
            nparray_reshaped = np.ctypeslib.as_array(
                image_buffer.pdata, (image_buffer.height, image_buffer.width)
            ).copy()
        
        elif image_buffer.bits_per_pixel == 12 or image_buffer.bits_per_pixel == 10:
            split=np.ctypeslib.as_array(image_buffer.pdata,(image_buffer.buffer_size,1)).astype(np.uint16)
            fst_uint12 = (split[0::3] << 4) + (split[1::3] >> 4)
            snd_uint12 = (split[2::3] << 4) + (np.bitwise_and(15, split[1::3]))
            nparray_reshaped = np.reshape(np.concatenate((fst_uint12[:, None], snd_uint12[:, None]), axis=1), 
                                          (image_buffer.height, image_buffer.width))

        elif image_buffer.bits_per_pixel == 16:        
            pdata_as16 = ctypes.cast(image_buffer.pdata, ctypes.POINTER(ctypes.c_ushort))
            nparray_reshaped = np.ctypeslib.as_array(
                pdata_as16, (image_buffer.height, image_buffer.width)
            ).copy()
        
        #nparray_reshaped=np.ctypeslib.as_array(image_buffer,(1,image_buffer.buffer_size))
        self.device.requeue_buffer(image_buffer)
        return nparray_reshaped

    def get_temp(self) -> float:
        return self.deviceSettings["DeviceTemperature"].value
        
    def get_mac(self)-> str:
        return ':'.join(['{}{}'.format(a, b)
                         for a, b
                         in zip(*[iter('{:012x}'.format(cam.deviceSettings['GevMACAddress'].value))]*2)])
    
@delegates()
class LucidCamera(LucidCameraBase, OpenHSI):
    pass
        

# %% ../nbs/api/cameras/lucidvision.ipynb 9
@delegates()
class SharedLucidCamera(LucidCameraBase, SharedOpenHSI):
    pass

# %% ../nbs/api/cameras/ximea.ipynb 5
@delegates()
class XimeaCameraBase():
        
    """Core functionality for Ximea cameras"""
    # https://www.ximea.com/support/wiki/apis/Python
    def __init__(self, exposure_ms:float = 10, serial_num:str = None, **kwargs):
        """Initialise Camera"""
        
        super().__init__(**kwargs)
                    
        from ximea import xiapi
        self.xiapi=xiapi # make avalaible for later access just in case.
        
        self.xicam = self.xiapi.Camera()
        
        self.xicam.open_device_by_SN(serial_num) if serial_num else self.xicam.open_device()

        print(f'Connected to device {self.xicam.get_device_sn()}')
        
        self.xicam.enable_horizontal_flip()

        self.xicam.set_binning_vertical(self.settings["binxy"][0])
        self.xicam.set_binning_vertical_mode("XI_BIN_MODE_SUM")

        
        # set window up.
        self.xicam.set_height(self.settings["win_resolution"][0] if self.settings["win_resolution"][0] > 0 else self.xicam.get_height_maximum())
        self.xicam.set_width(self.settings["win_resolution"][1] if self.settings["win_resolution"][1] > 0 else self.xicam.get_width_maximum())
    
        self.xicam.set_offsetY(self.settings["win_offset"][0] if self.settings["win_offset"][0] > 0 else self.xicam.get_offsetY_maximum())
        self.xicam.set_offsetX(self.settings["win_offset"][1] if self.settings["win_offset"][1] > 0 else self.xicam.get_offsetX_maximum())
        

        self.set_exposure(self.settings["exposure_ms"])
        
        self.xicam.set_gain_direct(0.0)

        self.xicam.set_imgdataformat(self.settings["pixel_format"])
        if self.settings["pixel_format"] == "XI_RAW16":
            self.xicam.set_output_bit_depth("XI_BPP_12")
            self.xicam.enable_output_bit_packing()
            
        self.xicam.disable_aeag()
        
        self.rows, self.cols = self.xicam.get_height(), self.xicam.get_width()
        self.img = xiapi.Image()
        
        
    def __exit__(self, *args, **kwargs):
        self.xicam.stop_acquisition()
        self.xicam.close_device()
        
    def set_exposure(self,exposure_ms:float):
            self.xicam.set_exposure_direct(1000*exposure_ms)
            self.settings["exposure_ms"] = self.xicam.get_exposure()/1000  # exposure time rounds, so storing actual value

    def start_cam(self):
        self.xicam.start_acquisition()
    
    def stop_cam(self):
        self.xicam.stop_acquisition()
    
    def get_img(self) -> np.ndarray:
        self.xicam.get_image(self.img)
        return self.img.get_image_data_numpy()
    
    def get_temp(self) -> float:
        return self.xicam.get_temp()

@delegates()
class XimeaCamera(XimeaCameraBase, OpenHSI):
    pass

# %% ../nbs/api/cameras/ximea.ipynb 9
@delegates()
class SharedXimeaCamera(XimeaCameraBase, SharedOpenHSI):
    pass